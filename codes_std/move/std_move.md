# std::move

## 思想

### 移动

在程序中涉及到大量的拷贝操作，将一个变量内容赋值一份然后放到另外一个变量内存中，然后很多时候，有很多临时变量，其生存周期非常短，如果对其也进行拷贝赋值操作，会造成不必要的资源浪费！

为了避免临时对象赋值拷贝造成的资源浪费，C++11引入了move概念，也就是可以直接“窃取”对象的内容！让一个对象的资源在销毁前，我们将其转移给其它对象再用起来，这样能减少资源带来的构造开销，程序获得更高的效能。

### 右值引用的必要性

思考一下，如果在避免内存拷贝的前提下，在函数外操作函数内创建的局部变量！

这个问题难点在于：

- 如果这个局部变量是内置类型，则不能

  ```c++
  int fun_int()
  {
      int a = 10;
      return a;
  }
  int main()
  {
      // 发生拷贝，b是需要重新开辟内存空间，无法访问fun_int()中的a了。
      int b = fun_int(); 
  }
  ```

- 由于无法返回局部变量的引用，因为引用本质是指针常量，局部变量在函数返回后被回收，故无法通过传递指针的方式使用局部变量

  ```c++
  int& fun_int()
  {
      int a = 10;
      return a;
  }
  int main()
  {
      // 不合法
      int b = fun_int(); 
  }
  ```



解决方法：使用右值引用！

对于非内置类型，返回函数内创建的局部变量时将不进行拷贝操作，而是移动操作，避免了因变量所占内存空间较大时效率降低的问题。

```c++
Student createStudent(){
    Student stu;
    cout << "移动变量." << "stu地址为：" << (int *)(&stu) << endl;
    return stu;
}

int main(){
    Student s = createStudent();
}
```

> 在c++11之前，局部变量stu在函数返回后就被销毁，当进行函数返回操作时进行内存拷贝至变量s，如果类型Student所在内存较大，则程序运行效率会降低。
>
> 在c++11之后，局部变量的返回方式时移动操作，只需要让新的变量s指向的内存空间为stu即可！！！

## 左值和右值

### 区别

当对象被作为右值的时候，用的是对象的值（内容）

当对象被作为左值的时候，用的是对象的身份（在内存中的位置）

> 我们把一个对象用放置在某个内存位置的**盒子**来形容，那么**盒子内的东西**就是对象的值！

```c++
//给变量sum1赋值，故变量sum1为左值，字面常量0是右值
int sum1 = 0;

//用临时变量sum1*10给对象sum2赋值，故sum2为左值，sum1*10为右值
int sum2 = sum1 * 10;  

// sum1与sum3都是左值！！！
int sum3 = sum1;
```

### 特性

- 变量是左值

  变量可以看作只有一个运算对象而没有运算符的表达式

- 左值持久，右值短暂

  左值一般在整个作用域内有效，而右值要么是字面常量，要么是在表达式求值结果中创建的临时变量

- 右值没有名字，不能改变（赋值）

```c++
int n = 10, m = 20;
int sum1, sum2;

sum1 = n + m;      //(n+m)是临时变量，没右名字，故是右值
sum2 = 10 + 20;    //(10+20)是临时变量，故是右值
sum2 = add(n, m);  //add返回值是临时变量，故是右值

n+m = 6;          //不合法，不能给右值赋值
add(n,m) = 100;   //不合法，不能给右值赋值
```

### 运算符操作



## 右值引用

引用就是给变量取别名，本质是一个指针常量（即指向是固定的，一旦初始化，不能更改指向其他对象）。

### 定义

通过&&定义一个右值引用。右值引用定义时必须赋初值，且只能使用右值赋值。

```c++
int &&rr = 1990;
```

右值引用一般绑定的都是临时对象，也就是即将销毁的对象。

### 与左值引用区别

- 可以将一个const的左值引用绑定到一个右值上！

```c++
int i = 1;
int &r2 = i * 40;   //错误
const int &r3 = i * 40;   //正确
```

- 右值引用不能通过=直接赋值，需要使用std::move()

```c++
int i = 20;
int &&rr1 = std::move(i);//rr1指向的地址与i一样
int &&rr2 = i * 10;

// int &&rr3 = rr2; //由于rr2是变量，故作为左值不能被右值引用绑定
int &&rr3 = std::move(rr2);//rr3指向的地址与rr2一样
```





## 移动构造函数

```c++
class Student
{
public:
    Student() = default;
    Student(const Student &);  // 拷贝构造函数
    Student(Student &&);       // 移动构造函数
private:
    std::string _name;
};

void test01()
{
    Student stu1;
    Student stu2(stu1);            // 调用拷贝构造
    Student stu3(Student());       // 优先调用移动构造函数，若没有定义移动构造，则调用拷贝构造（参数必须是const &）
    Student stu4(std::move(stu1)); // 同上
}
```

